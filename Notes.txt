Brief summary of major changes for this new v2.0 of QtFTM.

================================
1.) New HardwareObject interface
================================

HardwareObjects are now designed to have an additional virtual layer.
Each object from v1.0 (motordriver, ftm synth, oscilloscope, etc) is now an abstract base class whose pure virtual
functions need to be implemented in a child class.
These classes are now placed in the "implementations" pri file.
Each header file uses preprocessor defines that are set in the project file to choose a particular implementation at compile time.

HardwareObjects now have a "subKey" which ensures that settings are associated their particular implementation.
For instance, when switching from a virtual implementation to a real implentation, the settings (min, max, whatever) for one implementation
will not affect the other.
HArdwareObjects also have a new d_isCritical member.
By default, all hardware objects are critical, but I have set the flow controller and HV power supply to be not critical.
If an object is not critical, then the program controls will still be operational even if the device is not connected, though of
course some errors may occur.

================================
2.) nohardware configuration
================================

In the project file, there is a CONFIG += nohardware that allows the program to be built with all virtual hardware.
Alternatively, individual pieces of hardware may be set to virtual by setting appropriate values at the indicated positions in the pro file.
The program will issue warnings when virtual hardware is used.

================================
3.) Automatic error recovery
================================

Whenever a hardware failure is detected, the hardware manager will automatically attempt to reconnect to the device.
During a scan/batch, if the reconnection is successful, the current scan will automatically be retried (up to a maximum of three times).
In order to accomplish this, big changes were made to the hardware manager's tracking of whether instruments are connected, and whether the hardwarefailure signal is connected.
Now, the hardwareFailure signal is only connected to the hardware manager if the device is successfully connected, and that connection is severed if a failure occurs.

================================
4.) New Pulse configuration class and widget
================================

Instead of a list, the program now has a dedicated PulseGenConfig class to handle the pulse generator settings.
Important channels are indicated with preprocessor defines.
There is a dedicated function for toggling DC and DR pulses on and off so that other places in the code don't need to know details of PGen implementation.
Along with the new data storage class, there is a new widget used throughout the program for configuring the channels.
The names and active levels for each channel can be configured by hitting the small wrench button, and you can also configure the default step size for the width and delay boxes.
The PulseConfigWidget also handles the rep rate and the scope and protection delays.
The PulsePlot is now part of the PulseConfigWidget, and it shows the scope and protection pulses as vertical markers.

================================
5.) New Flowconfig class
================================

Similar to the pulse gen config, the flowconfig class stores relevant information about the gas flow setup.
Some details about its use are a bit different, particularly when loading scans.

================================
6.) New Led class
================================

Instead of the QML object that was used in previous versions, there is a new Led class that is derived from QWidget.
It provides a setState command that toggles the LED on and off.

================================
7.) New Batch Plots
================================

The batch plot code has been completely redone.
A batch plot now has an abstract base class that defines an interface and keeps track of the curve and autoscaling settings.
Each type of batch now has an implementation of the base class that allows custom handling of the batch data.
For the most part, the new classes work the same as the old BatchPlot class, but they are much more maintainable now.
One new feature is that if a fine tune fails, the scan will be highlighted in red on the plot.

================================
8.) CommunicationProtocol class
================================

Instead of being subclasses of HardwareObject, common communication interfaces are now their own objects which are children of a HardwareObject.
The CommunicationProtocol class defines pure virtual functions for communication, which must be implemented in a derived class (eg Rs232Instrument).
As of now, there are 5 types of communication protocols: RS232, TCP, GPIB, Virtual, and Custom.
If a real piece of hardware does not communicate via RS232, TCP, or GPIB, it must create a CustomInstrument protocol.
Virtual instruments must create a VirtualInstrument protocol.
The prorgam will issue a warning for each virtual instrument when it connects.

GPIB instruments require special attention.
When creating a GpibInstrument comm protocol, it must take a GpibController as one of the parameters in its constructor.
That GpibController must be the parent of the HardwareObject that is using the GpibInstrument.
Furthermore, the HardwareObject must be in the same thread as the GpibController.
See the implementations for the HP FTM and DR synthesizers for examples of how to do this if adding a new GPIB instrument

================================
9.) HV Power Supply class
================================

There is a HvPowerSupply HardwareObject and a virtual implementation that is controlled by the voltage boxes on the UI and in the scan widget.
When we get a real power supply that can be controlled, create an implementation for it in a manner similar to the other instruments.
To go along with this, there is a new ftb file command "dcvoltage" that you can use to control the discharge voltage for each scan.
This voltage is now displayed on the batchwidget when configuring a batch.

================================
10.) Skip tune simplification
================================

Unnecessary fields in the scan object related to tuning were removed because there was already a skipTune field that controlled whether tuning would happen for a particular scan.
Scan::skipTune is now used throughout to control whether tuning should be skipped.
If tuning is skipped, the cavity voltage will still be measured.
A new ftb file command "skiptune" now allows you to control whether tuning is skipped for each scan in a batch.
Additionally, the skipTune checkbox in singlescanwidget is now enabled in the batchWidget when creating and editing scans with the UI.
As a result of these changes, the MotorDriver::canSkipTune() function has been removed.
Now, tuning will ALWAYS occur prior to a scan UNLESS Scan::skipTune is set to true.

================================
11.) datastructs.h
================================

There is now a header file that contains some program-wide data structures and enums.
These are all defined in the QtFTM namespace.
Essentially, any struct or enum that is used outside of one particular class should be placed in that namespace.
I have not gone through the entire program to ensure this is done for every class, though, so there may still be some inconsistencies.

================================
12.) Log file
================================

The loghandler now records all of its messages to log files.
These are stored in <savepath>/log/YYYYMM.log (by default, savepath is /home/data/QtFTM)
A new log file is created each month so tha they don't get too long.
In the log file, errors, warnings, and debug messages are prepended with [ERROR], [WARNING], or [DEBUG], as appropriate.

================================
13.) QtFTM::LogDebug
================================

Debugging messages can be sent to the log with the new QtFTM::LogDebug flag.
In release builds, these messages will only appear in the log file; in debug builds, they will also appear in the UI log.
